# 테스트
## 1.1 테스트의 목적
1. **결함의 검출**과 제품 품질 개선
2. **품질 평가**와 의사 결정 지원
3. **개발 프로세스** 개선 지원

---

## 1.2 오류, 결함, 장애

### 소프트웨어 요구사항
소프트웨어를 **개발할 때** 기대, 약속된 소프트웨어의 동작에 대한 **기준**

### 1. 오류 (Error)
결함이 생기게 한 **개발자의 행위**

### 2. 결함 (Defect)
소프트웨어 내에 **장애를 유발할 수 있는 문제**. 

1️⃣ **누락 (Omission)**

요구명세에 명세된 **요구사항이 시스템의 구현에 반영되지 않음**

ex) 근이 공식에서 두 개의 허근을 가질 경우를 포함하지 않음

2️⃣ **부정확한 (Incorrect) 구현**

요구명세에 명시된 **요구사항이 소프트웨어에 부정확하게 반영**, 성능보안안전 등 품질요소와 관련된 부정확한 구현도 포함

ex) 근의 공식에서 2차항의 계수 a가 0인 경우를 포함하지 않음

3️⃣ **비관련 (Extraneous) 결함**

**요구명세와 관련되지않은 구현**, 당장 직접적인 장애를 유발하지 않을수도
서비스의 기능, 품질에 기여하지 않는 무의미한 코드도 다른 결함을 초래

- 결함 발생 단계 : 코딩 35%, 설계 25%, 요구분석 20%, 문서화 12%, 결함해결오류 8%
- 결함 해결 비용 : **요구분석 < 설계 < 코딩 < 단위테스팅 < 인수테스팅 < 유지보수**

        결함이 있다고 해서 반드시 오류가 생기는 것은 아니다 

### 3. 장애 (Failure)
소프트웨어가 **요구사항과 다르게** 동작

---

### 테스팅 (Testing)
- 실제 동작과 요구사항의 차이를 확인
- 결함 발견을 목적으로 장애 발생을 확인하여 결함의 존재여부를 **간접적으로 판단**
- 테스팅의 결과는 **테스트 케이스 test case + 테스트 환경 test env.**
- 어떤 모듈에서 발생했고 어떻게 수정해야하는지는 몰루 !

### 디버깅 (Debugging)
- 먼저 테스팅을 통해 결함의 존재 확인 -> **결함의 위치** 파악, **결함을 제거**하는게 목적
- 소스 코드의 위치를 알아내고 소스 코드를 수정

### 재테스팅 (Re-testing)
- 실제로 결함이 제거되었는지 확인. 
- **초기**에 결함을 검출한 **테스트 케이스를 다시 이용**

---

## 1.3 테스트의 현실/실제
무한한 입력값을 사용해야함 ..
다익스트라 왈 '프로그램 테스트는 결함이 있음을 보일 수는 있지만, **결함이 없음을 보일 수는 없다.**'

따라서 최대한 **효과적이고 효율적**인 테스트 수행. 위험 기반 테스트 방법을 적용할수도 있음 !

### 테스트의 진화 과정
⊢ 레벨 1 (Debugging-oriented) : **우연히 발견된 결함**을 수정하는 디버깅

| 1957'

⊢ 레벨 2 (Demonstration-oriented) : 결함보다는 **시스템의 정상 작동을 증명**하는데 초점

| 1979'

⊢ 레벨 3 (Destruction-oriented) : **결함을 발견**하는 테스트케이스의 중요성 인식

| 1983'

⊢ 레벨 4 (Evaluation-oriented) : 소프트웨어 **개발 전** 단계에서 결함 발견하는 개념으로. 지속적으로 리뷰하는게 중요함

| 1988'

⊢ 레벨 5 (Prevention-oriented) : **아예 결함이 발생하지 않도록 사전에 방지**, **테스트 케이스를 미리 설계**하는 것이 가장 효과적. -> 테스트 주도 개발(Test-Driven Development, TDD)

---

### 테스트 원칙
1. 테스트는 반드시 프로그램을 **개발한 프로그래머나 팀과는 무관한** 그룹이 수행해야 함
2. 결함이 **발견되지않으리라는 가정하에** 테스트 **계획을 수립해서는 안됨**
3. 타당한 경우뿐만 아니라 **타당하지 않고 예상하지 못한 경우에 대해서도** 테스트를 수행해야 함
4. 프로그램의 어떤 부분에 **결함이 남아있을 확률**은 그 부분에서 **이미 발견된 결함의 수에 비례**
- 파레토 (Pareto) 원칙 : " 프로그램 결함의 **80%는 20%의 모듈에서 발생**한다"
- 따라서 많이 발생한 부분에 테스트 노력을 집중하는 게 효과적임
5. **테스트 케이스**는 체계적으로 관리

        기존에 만들었던 테스트 케이스를 재사용하여 테스트하는 것이 바람직
6. 각각의 **테스트 케이스**를 철저하게 **점검**

---

## 1.4 테스트와 품질
품질 특성 분류
- 기능 적합성
- 성능 효율성
- 호환성
- 사용성
- 신뢰성
- 보안성
- 유지보수성
- 이식성

**기능(Functional) 테스트**

**비기능(Non-functional) 테스트** : 품질 요구사항에 초점을 둠. 성능, 호환성, 사용성 등

**유형 테스트** : 각 품질 특성별로 따로 테스트를 수행해야. 

---

### V&V (Verification & Validation, 검증과 확인)
- 검증 : 수행한 **활동의 적합성**
- 확인 : **결과물의 적합성**
1) **정형 방법**
1️⃣ 모델체킹
2️⃣ 정확성 증명
2) **테스팅**
1️⃣ 동적 테스팅
2️⃣ 정적 테스팅
3) **V&V 분석**
1️⃣ 시뮬레이션
2️⃣ 평가

### 품질 보증
- **의도한 목적**에 적합한 소프트웨어 **제품을 개발**했는지 + **프로세스가 적합**한지 확신을 주기 위해서 수행하는 다양한 활동
- 프로세스 품질을 수행한다는 측면에서 V&V보다 광범위함

---

## 1.5 테스트 기본 용어
- **테스트 대상** : 결함을 검출하려는 대상 소프트웨어

- **시스템 테스트** : 전체 소프트웨어가 대상
- **단위(Unit) 테스트** 혹은 **컴포넌트(Component) 테스트** : 부분이 대상
- **통합 테스트** : 각 부분의 연결에 초점
- **레벨 테스트** : 시스템 테스트 + 컴포넌트 테스트 + 통합 테스트

---

- **피처 (Feature)** : 테스트 대상의 특성 중 **테스트하고자 하는 측면/관점**

---

### 정적 테스트 (Static Testing) VS 동적 테스트 (Dynamic Testing)
| 테스팅 | 정적 테스트 | 동적 테스트 |
| ---- | ---------------- | ----------------|
| 특징 | 테스트 대상 실행 X ! | SW 실행 -> 결과 비교 |
| 장점 | 소스코드 작성 **이전 개발** 수행 가능, 경제적, 자동화 도구 | **소스코드 사용 안함 !!!** |
| 단점 | **오검지** (결함 아닌데 결함이라고) | SW 실행환경 필요 |

더 자세하게 살펴보면
1. 정적 테스트

1️⃣ **리뷰** : 결함 검출이 목적, 정확하게 반영되었는지 **검토**

2️⃣ **정적분석** : **결함으로 판단할 수 있는 특정한 패턴**이 있는지 검토

2. 동적 테스트

1️⃣ **명세 기반 방법** : 내부 논리 구조 참조X, **요구 명세**나 **설계 정보** 이용 적용대상에 제한 X, 전 과정에 걸쳐 사용됨

2️⃣ **구조 기반 방법** : ( = 구조적 테스트, 화이트박스 테스트, 글래스 박스 테스트 ) 프로그램 **제어 흐름이나 자료 흐름** 정보 이용. 

3️⃣ **경험 기반 테스트** : 테스트의 **경험**, **기존** 테스트 **결과**, 테스터의 **직관** 활용
- **오류추정**
- **탐색적 테스트**

---

- **테스트 케이스** : 입력과 대응되는 예상 결과를 묶은 것 ! `{입력 : 예상결과}`
- **테스트 절차** : 테스트를 준비하고 실행하고 결과를 관찰하고 기록하는 절차
- **테스트 스크립트** : 테스트 절차를 **자동화 도구가 해석하고 실행하는 언어**로 작성한 것
- **테스트 환경** : 테스트 대상을 실행하는 모든 환경 (+드라이버, 스텁, 테스트 도구 등등 ..)

하나의 테스트 대상에 대해 **복수의 피처**가 있을 수도 있고 이 경우에는 **각 피처에 대한 테스트가 수행**됨. 동적 테스트 방법을 적용할 때 **복수 개의 테스트 케이스**가 설계됨. **하나의 테스트 케이스는 여러 테스트 절차에서** 사용될 수 있음.



