# [06] 소프트웨어 생명 주기 모델과 테스트

소프트웨어 개발 주기가 있지만 규모와 특성에 따라 다양한 방식으로 개발

- **Code-and-Fix 모형** : 테스트 작업을 별도로 분리해 수행하지 않고 디버깅 작업의 한 부분으로 수행할 수도 있음

## 1. 순차적 개발 모델

### 1) 폭포수 모델

✏️ *개발 중심 모델, 테스트를 하나의 개발단계로만 간주*

- **요구사항 분석** : 요구사항 수집, 문제 이해, 분석, 명세화 → 요구사항 명세
- **구조 설계 단계** : 전체적인 구조 결정, 구성요소 의존성 파악 → 전체적인 아키텍처 보여주는 설계 명세
- **상세 설계 단계** : 각 모듈의 세부 사항 → 모듈 명세를 포함하는 상세 설계 명세
- **코딩** : 실제 기계가 해독할 수 있는 언어로 → 프로그램
- **테스팅** : 결함 검출 위해 테스트 수행

폭포수 모델의 장점 :
문서와 정보가 많이 산출 → 정보 쉽게 얻음 (✏️*역사 + 안정성*)

폭포수 모델의 단점 : 테스트 작업을 코딩 단계 후의 작업으로 취급. 비용, 개발 일정에 심각한 영향 끼치고 구조 설계상의 문제이면 아예 고치지 못할수도있음

### 2) V-모델

**테스트를 개발과 동등하게 취급**

- **테스트 활동은 개발이 시작됨과 동시에**
- 단위 및 통합 테스트 단계가 종료되길 기다릴 필요가 X, 각 개발단계의 산출물 이용 가능
- V&V 모델 : Verification **검증** (시스템이 명세를 만족시키는지 검사) + Validation **확인** (시스템이 사용자의 요구사항을 만족시키는지 검사)

✏️ *개발 산출물에 대한 정적 테스트가 수행됨*

# ↘ ↗

SDLC  STLC

(개발관련) (테스트관련단계)

---

### 2. 진화적 개발 모델

요구사항이 명확하지 않은 경우 사용됨

✏️ *요구사항이 계속 변하기 때문에 오히려 프로젝트 관리는 어려움*

이터레이션 + 점진적 (Incremental) 개발 원칙 = 핵심 부분을 개발한 후, 여러 이터레이션 통해서 개선 발전시켜 최종 개발. 각 이터레이션의 결과물이 고객에게 전달

### ex) 나선형 개발 모델

프로세스 한 주기마다 사용자에게 피드백 받아서 good

✏️ *한 모델만 이용하지 않고 다양한 모델을 포괄해서 **메타 모델**이라고도 부름*

---

### 3. 애자일 개발 모델

### 애자일 선언 (Agile Manifesto)

- **사람 및 상호 의사 교환** > 프로세스, 도구
- **동작하는 소프트웨어** > 포괄적인 문서
- **고객과의 협력** > 계약 협상 (우선)
- **변화에 반응** > 계획을 따르는 것
    
    **반복적이면서 점진적인 개발 접근 방식 (IDD**, Iterative and Incremental Developemnt) 따름 → 개발 주기를 여러 개의 이터레이션으로 구분. 외부적으로 릴리즈되는것은 최종 반복의 산출물이다
    

대표적인 애자일 방법

### XP (eXtreme Programming)

지속적인 개발을 위해 프로그래머가 **과도한 작업을 피하는 것**이 매우 중요함. 과도한 작업은 오히려 역효과를 불러일으킴 → ✏️ *짝 프로그래밍, 소규모 릴리스, 점증적인 계획 수립*

### 테스트 주도 개발 (TDD, Test-Driven Development)

프로그램 **테스트 케이스 먼저 개발** → 실제 프로그램의 **통과하는 코드 나중에 작성**

필요하면 ✏️**리팩토링** (Refactoring, 기능을 변경하지 않고 **내부 구조**를 개선) 진행 → ✏️ *리팩토링 끝나면 수정된거니까 리그레션 테스트 수행해야 함*

- 결함의 발생 가능성 감소
- 테스트 용이성
- 변경 요구에 쉽게 대응
- 요구 사항을 분명하게 드러내줌
- ✏️ *TDD는 대표적인 애자일 방법이다 !*

### 지속적 통합 (CI, Continuous Integration)

- 통합 지연 방지, 빠른 결함 발견으로 비용 감소
- 항상 빌드가능한 SW가 있음 → 소프트웨어 품질에 대한 확신