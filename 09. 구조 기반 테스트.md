# [09] 구조 기반 방법 (Structure-based test)

(= 구조적 테스트, 화이트박스 테스트, 글래스 박스 테스트)

**제어 흐름이나 자료 흐름 정보** 이용하여 테스트 케이스 설계.

일부 경로만 테스트하는 방법 사용 !

✏️ ***사이클로매틱 복잡도** **V(G) = P + 1** = 결정 노드 (간선2개이상인 노드) + 1*

✏️ ***테스트 커버리지** : 높을수록 감지하는 결함이 다양해짐*

✏️ *정상 패턴*

| **패턴** | **설명** | **코드 흐름 예시** |
| --- | --- | --- |
| **dd** | **정의 후 정의** (Define → Define) | 변수에 값을 할당한 후, 다시 값을 할당함 (예: `x=5; x=10;`) |
| **du** | **정의 후 사용** (Define → Use) | 변수에 값을 할당한 후, 그 값을 사용함 (예: `x=5; y=x+1;`) |
| **uu** | **사용 후 사용** (Use → Use) | 변수의 값을 사용한 후, 다시 사용함 (예: `y=x+1; if(x>0)`) |
| **kk** | **정의되지 않은 상태** 후 **정의되지 않은 상태** (Kill → Kill) | 변수가 정의되지 않은 상태를 유지함 |

✏️ *이상 패턴*

| **패턴** | **설명** | **잠재적 오류** |
| --- | --- | --- |
| **~u** (또는 **ku**) | **정의되지 않은 상태** 후 **사용** (Kill → Use) | **초기화되지 않은 변수 사용.** 변수에 값이 할당되지 않은 상태에서 사용되어 쓰레기 값이 사용될 위험. |
| **ud** | **사용 후 정의** (Use → Define) | **변수 사용 후 바로 값을 덮어씀.** 사용한 변수의 결과가 다음 정의로 인해 **덮어씌워져** 사용되지 않을 가능성 (비효율성). |
| **uk** (또는 **~d**) | **사용 후 정의되지 않음** (Use → Kill) | 변수가 사용된 후 **다시는 사용되지 않고 사라짐**. 이는 사용 자체는 괜찮지만, 변수가 무의미하게 남아있거나 **사용 직후 사라져서 문제**가 될 수 있음. |

### 1) 문장 테스트

모든 (실행 가능한) 문장 최소한 한번은 행하도록

**문장 커버리지** : 테스트 케이스 집합에 의해 문장 테스트가 어느 정도 이루어졌는지 정량적으로 알수있게 해주는 정도.

= ✏️ *(**실행된 문장**의 수)/(**전체** 실행가능한 프로그램 **문장**의 수)*

### 2) 결정 테스트

모든 결정문의 결과가 **참이 되는 경우와 거짓이 되는 경우를 최소한 한번씩**

✏️*결정 테스트는 가능한 모든 조합을 생성하고 문장 테스트를 포함*

**결정 커버리지** 

- (**실행된 결정문**의 결과 수)/(**전체 결정문**의 결과 수)
- ✏️*그래프에서도 각 결정이 모든 경우의 수 다 가봤어야 완전히 테스트한 것*

✏️ 결정 커버리지 100%이려면 최소 테스트 케이스 4개

```c
int computeBill(int a){
	int b = 0;
	if (a > 120) { // 조건 1 // 1️⃣F 2️⃣3️⃣4️⃣T
		if (a <= 240) // 조건 2 // 2️⃣T 3️⃣4️⃣F
			b = (a - 120)*2;
		else {
			b = (a - 240)*2; // 조건 3 3️⃣T 4️⃣F
			if (b >= 100) b = b*3;
		}
}
return b;
```

### 3) 조건 테스트

모든 조건이 **true가 되는 경우와 false가 되는 경우** 모두를 발생하게 하는 입력 데이터를 테스트 집합으로 사용

**조건 커버리지** = (**실행된 개별 조건**의 결과 수)/(**개별 조건**의 결과 수)

*✏️각 **개별 불리언 조건**이 **참**과 **거짓**값을 **최소 한 번씩** 갖도록 테스트*

|  | **X > 1** | **Y == 1** | **X == 2** | **Y > 1** |
| --- | --- | --- | --- | --- |
| **TC1** | F | F | F | T |
| **TC2** | T | T | T | T |
| **TC3** | F | F | F | F |

*면 TC2와 TC3만으로도 T와 F 모두 갖게되므로 TC1은 필요없어짐 !*

✏️ *다음 프로그램에 (X=10, Y=5), (X=15, Y=0)의 테스트 케이스 실행하였을 때 **조건 커버리지**는 60% = 1+1+2+1+1/10*

```c
IF ((X>=6) || (Y>14)) // T / F
	Z = X + Y
IF ((X<Z) && (Y>14)) // T, F / F
	Z = X
IF (X<=Z) // T
	RETURN 0
```

조건 테스트와 결정 테스트는 서로 포용하지 않음 !

### 4) 결정/조건 테스트

모두 만족하는 테스트케이스

**결정/조건 커버리지** = (**실행된 조건문과 개별 조건**의 결과 수)/(**전체 결정문과 개별 조건**의 결과 수) 

✏️ *참과 거짓을 적어도 한번 이상 실행, 테스트 케이스 수트에 의해 실행된 전체 조건식과 기본 조건식이 몇%인지 특정*

### 5) 다중 조건 테스트

**✏️ *다중 조건 커버리지** 100% 만족하는 최소의 테스트 케이스 수 = 2^N개 즉 8개 !*

---

- ✏️ ***분기 커버리지**: 모든 분기가 최소한 한번은 실행되야*
- ✏️ ***조건/분기 커버리지**: 분기 커버리지(IF문) 때 둘 다 T거나 F면 하나로 셈*
- ✏️ ***조건/결정 커버리지**: 기본 조건식 및 전체 조건식 결과가 참과 거짓을 적어도 한번 이상 실행시키는 것을 기준으로*