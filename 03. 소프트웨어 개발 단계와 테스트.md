# [03] 소프트웨어 개발 단계와 테스트

### 1) 컴포넌트 테스트

- 개별적인 모듈의 테스트, 컴포넌트를 **독립적인 방식**으로 수행
- **테스트 환경** = 테스트 베드(Test bed), 개별적인 모듈에 대해 컴포넌트 테스트를 수행
✏️ *일반적으로 개발자에 의해 수행됨*
    - 단위테스트 드라이버(Driver)
        
        ↓
        
        컴포넌트
        
        ↓
        
    - 단위테스트 스텁(Stub)

### 모의 객체 생성 프레임워크

- **모의(Mock) 객체** : 객체 지향 프로그램에서는 테스트되는 메소드가 다른 테스트 객체에 의존할 수 있기 때문에 스텁의 객체 지향버전이 필요
- **fixture** : 테스트에 필요한 상황을 생성하는 부분(setup 부분)

1️⃣ 테스트에 필요한 객체 **생성**하거나 자원 할당

2️⃣ 실제 테스트하는 기능을 호출하는 **동작**

3️⃣ 동작의 실행 결과와 기대 결과를 비교하는 **확인**

+) 모의 객체의 분류

- **더미 (Dummy) 객체** : 객체만 필요하고 객체의 **기능까지는 필요X**
- **테스트 스텁 (Stub)** : 더미 객체에 단순한 **기능성** 작성, 상태 가정해서 특정값 리턴하거나 특정 메시지 출력
- **테스트 스파이 (Spy)** : ✏️*테스트 대상 클래스(CUT)와 **협력하는 클래스로 가는 출력을 검증***
- **가짜(Fake) 객체** : ✏️*실제 **협력 클래스 중 기능 대체**해야 할 경우에 사용, 전체나 일부를 훨씬 **단순하게 구현***

### FIRST 원칙 !

### Fast

빠르게 수행되어야 함 ! 컴포넌트 테스트의 주요 목적 중 하나는 리그레션 테스트. 외부 자원에 의존할 경우 **모의 객체 생성 프레임워크** 사용

### Isolated

의존X. 독립적으로 수행. 전체 컴포넌트 결과 == 개별적 컴포넌트 결과 여야 함 !

### Repeatable

몇번을 수행해도 동일한 결과여야함. 개발자 자신만이 사용할 수 있는 샌드박스 구축 추천

### Self-Validating

사람의 개입 없이 ! 자동화 ㄱㄱ

### Timely

제때 수행되어야함 (✏️ *TDD에서는 코드 작성 바로 전* )

### Unit Test Framework

✏️ *기본 경로를 확인함으로써 **구조적 테스트 강화***

*✏️ 경곗값 확인함으로써 **입력값 범위에 따른 처리 결과** 확인*

*✏️ 에러 핸들링 경로 확인함으로써 **기능의 안정적 동작** 확인*

### 2) 통합 테스트

컴포넌트를 통합 ! **상호 연동**이 제대로 되었는지. 통합 대상이 먼저 결정되어야함.

통합 테스트의 목적

1️⃣연결의 정확성 (즉 데이터 누락/변경/전달순서 변경) → 전송 데이터에 대한 로그와 수신 데이터에 대한 로그 값 비교 OR **핑거 프린트(Finger Print)** 로 로그 크기 최소화

2️⃣연결된 컴포넌트의 기능적인 측면

통합의 방식

- **백뱅(Big-bang) 방식** : 전체 컴포넌트 한번에 통합. 오동작의 원인 파악 어려움 (✏️ *단위 테스트 생략은 절대안됨 !!!! 널리 쓰이는 방식은 아님*)
- **점진적(Incremental) 방식** : 적은 수의 컴포넌트 차례로 통합. 장점 : 오작동 원인 파악 쉬움 / 단점 : **테스트 드라이버 및 스텁 여러번 개발해야**함
    
    ### 1️⃣ **상향식 통합** (하→상)
    
    하위 컴포넌트 식별하여 **그룹화 + 클러스터링**하여 테스트 드라이버 작성하여 테스트 수행.
    
    - **클러스터(Cluster)** / **빌드(Build)** : 여러 모듈의 묶음
    - 장점 : 하위 컴포넌트 충분히 테스트 가능 + 하향식 통합에서 필요한 테스트 스텁 비용 X. 하위에 있을수록 빈번하게 사용하는 코드를 갖는다고 간주 가능
    
    ### 2️⃣ **하향식 통합** (상→하)
    
    상위 컴포넌트가 시스템의 기능, 하위 컴포넌트는 기능을 보조. 상위 컴포넌트의 결함은 **상위 컴포넌트를 반복적으로 테스트하는 하향식 통합 테스트 방식으로 빠르게 발견 가능** but 테스트 스텁 비용이 비싸면 bad
    
    - 1 하위 컴포넌트를 **테스트 스텁으로 대치** 후 테스트 수행
    - 2 DFS나 BFS 이용하여 테스트 스텁을 **한번에 하나씩 실제 컴포넌트로 대치**, 실제 호출되는 하위 컴포넌트를 **스텁으로 대치**
    - 3 시스템에 변경이 일어났으므로 **리그레션 테스트 수행**
    
    ex.
    
    드라이버
    
    ↓
    
    컴포넌트 0
    
    ↓
    
    컴포넌트 1
    
    ↓
    
    컴포넌트 2 일 때
    
    | 통합 순서 | 상향식 통합 | 하향식 통합 |
    | --- | --- | --- |
    | 1차 | 컴포넌트 1 컴포넌트 2 | 컴포넌트 0 컴포넌트 1 |
    | 2차 | 컴포넌트 0 컴포넌트 1 | 컴포넌트 1 컴포넌트 2 |
    
    ### 3️⃣ **샌드위치식 통합**
    
    **상위는 테스트 스텁 이용**, **하위는 클러스터링하여 테스트 드라이버** 이용하여 *✏️동시에 테스트*. 클러스트 테스트 와녈되면 실제 컴포너너트 통합해서 구축
    

### 3) 시스템 테스트

통합 테스트가 완료된 후에 전체 시스템이 **시스템 명세에 따라 개발**되었는지 검증. 시스템의 기능적인 측면 + 비기능적인 측면 (성능, 호환성, 사용성, 신뢰성, 보안성, 유지보수성, 이식성)도 검증. 필요하다면 시스템 테스트 전에 **스모크 테스트**(빌드가 테스트할 수준인지 확인용)

### 4) 인수 테스트

**고객의 입장**에서 평가

✏️ *운영 환경에서 **사용자에 의해 테스트**됨*

✏️ *테스트 대상이 시스템 전체 !*

- **알파 테스트(Alpha test)** : 선택된 사용자가 **개발자 환경에서** 통제된 상태로 수행
- **베타 테스트(Beta test)** : 일정 수의 사용자에게 소프트웨어 사용하게하고 피드백 받음 (**개발자 X**)

### 5) 리그레션 테스트

소프트웨어 수정이 이루어지는 이유, 유지보수 단계에서

- **결함 수정** 작업 (21%)
- **기능 보강** 작업 (50%)
- **적응** 작업 (25%) : 새로운 운영환경에 적응
- **예방** 작업 (4%) : 더 나은 유지보수를 위해 기존의 SW 시스템에 대한 문서 준비, 시스템 구조에 대한 유지보수

유지보수에서는 **개발 단계에서 사용했던 테스트 케이스를 이용**

✏️ *‘개발 중 고객과의 의사소통 부족’은 유지보수단계가 아닌 요구사항 정의 및 설계 단계임 !*

⭐ 기능이 더이상 필요하지 않아 앱에서 제거되었다면, **이를 테스트하는 테스트케이스도 리그레션 테스트 케이스 집합에서 제거되어야** 함 ⭐

중요하게 고려할 사항 : 테스트 케이스의 **규모**

리그레션 테스트의 방식

### 1️⃣ **Retest-All 방식**

개발된 모든 테스트 케이스 사용, 시간 자원 너무 많이 필요

### 2️⃣ **선택적 리그레션 테스트**

슬라이싱 기법, 자료 흐름 분석 기법과 같은 **변경 영향 분석(Change impact analysis)** 통해 서로 다른 결과 출력할 수 있는 테스트 케이스 식별

### 3️⃣ **테스트 최소화 방식**

**중복된 테스트케이스 제거** → **커버리지** 개념
but 변경되는 부분이나 변경에 의해서 영향받는 부분을 테스트하는 테스트 케이스가 제거될 위험이 있음

### 4️⃣ **테스트 우선순위화 방식**

가능한 빨리 많은 결함을 검출할 수 있도록

- **APFD (Average Percentage Faults Detected)** : 실행 수 대비 검출된 결함의 비율 (높을수록 많은 결함을 빨리 검출)로 수식에 테스트 케이스 수, 결함의 수, 실행 순서로 이루어져있음

```
APFD = ( 1 - ((Tf1 + Tf2 + ... + Tfm)/(m*n)) + (1/2*n)) * 100

# n : 테스트 케이스의 수
# m : 결함의 수
# Tfi : 결함 i를 검출하는 테스트 케이스의 위치

```